
; head and tail for n-ary operators with null terminators
(program sc_string_head ((t term)) term (nary_head f_str.++ t))
(program sc_string_tail ((t term)) term (nary_tail f_str.++ t))

(program sc_string_singleton_elim ((t term)) term (nary_singleton_elim f_str.++ t emptystr))
(program sc_string_singleton_intro ((t term)) term (nary_singleton_intro f_str.++ t emptystr))

; return reverse of t if rev = tt, return t unchanged otherwise
(program sc_string_rev ((t term) (rev flag)) term (ifequal rev tt (nary_reverse f_str.++ t emptystr) t))

(program sc_string_reduction ((t term)) term
  (match t 
    ((apply t1 t2)
      (match t1
        ((apply t11 t12)
          (let k (skolem t)
          (match t11
            ((apply f_str.substr t112)
              ;    // processing term:  substr( s, n, m )
              ;    // IF    n >=0 AND n < len( s ) AND m > 0
              ;    // THEN: s = k1 ++ k ++ k2 AND
              ;    //       len( k1 ) = n AND
              ;    //       ( len( k2 ) = len( s )-(n+m) OR len( k2 ) = 0 ) AND
              ;    //       len( k ) <= m
              ;    // ELSE: k = ""
              (let npm (int.+ t12 (int.+ t2 (int 0)))
              (let k1 (skolem (str.substr t112 (int 0) t12))
              (let k2 (skolem (str.substr t112 npm (int.- (str.len t112) npm)))
              (ite Bool
                ; condition
                (and (int.>= t12 (int 0))
                  (and (int.> (str.len t112) t12)
                    (and (int.> t2 (int 0))
                      true)))
                ; if branch
                (and (= t112 (str.++ k1 (str.++ k (str.++ k2 emptystr))))
                  (and (= (str.len k1) t12)
                    (and (or (= (str.len k2) (int.- (str.len t112) (int.+ t12 (int.+ t2 (int 0)))))
                           (or (= (str.len k2) (int 0))
                             false))
                      (and (int.<= (str.len k) t2)
                        true))))
                ; else branch
                (= k emptystr)
                )))))
            (f_str.contains true)  ; TODO
            ((apply f_str.indexof t112) true)
            ((apply f_str.replace t112) true)
            ; str.update
            ; str.from_int
            ; str.to_int
            ; seq.nth
            ; str.replaceall
            ; str.replace_re
            ; str.replace_re_all
            ; str.tolower
            ; str.toupper
            ; str.rev
            ; str.leq
  ))))))
)

(program sc_re_unfold_pos ((t term) (r term)) term
; TODO
  (fail term)
)
