; sorts :
(declare Bool sort)
(declare Int sort)
(declare Real sort)
(declare String sort)
(declare RegLan sort)
(declare Array (! i sort (! e sort sort)))
(declare BitVec (! w mpz sort))
(declare FloatingPoint (! e mpz (! s mpz sort)))
(declare Set (! e sort sort))
(declare Bag (! e sort sort))
(declare Seq (! e sort sort))

; Arithmetic
; Reals
(declare real (! v mpq term))
(declare f_real.+ term)
(define real.+ (# x term (# y term (apply (apply f_real.+ x) y))))
(declare f_real.- term)
(define real.- (# x term (# y term (apply (apply f_real.- x) y))))
(declare f_real.u- term)
(define real.u- (# x term (apply f_real.u- x)))
(declare f_real.* term)
(define real.* (# x term (# y term (apply (apply f_real.* x) y))))
(declare f_real./ term)
(define real./ (# x term (# y term (apply (apply f_real./ x) y))))
(declare f_real./_total term)
(define real./_total (# x term (# y term (apply (apply f_real./_total x) y))))
(declare f_real.> term)
(define real.> (# x term (# y term (apply (apply f_real.> x) y))))
(declare f_real.>= term)
(define real.>= (# x term (# y term (apply (apply f_real.>= x) y))))
(declare f_real.< term)
(define real.< (# x term (# y term (apply (apply f_real.< x) y))))
(declare f_real.<= term)
(define real.<= (# x term (# y term (apply (apply f_real.<= x) y))))
; Integers
(declare int (! v mpz term))
(declare f_int.+ term)
(define int.+ (# x term (# y term (apply (apply f_int.+ x) y))))
(declare f_int.- term)
(define int.- (# x term (# y term (apply (apply f_int.- x) y))))
(declare f_int.u- term)
(define int.u- (# x term (apply f_int.u- x)))
(declare f_int.* term)
(define int.* (# x term (# y term (apply (apply f_int.* x) y))))
(declare f_int.> term)
(define int.> (# x term (# y term (apply (apply f_int.> x) y))))
(declare f_int.>= term)
(define int.>= (# x term (# y term (apply (apply f_int.>= x) y))))
(declare f_int.< term)
(define int.< (# x term (# y term (apply (apply f_int.< x) y))))
(declare f_int.<= term)
(define int.<= (# x term (# y term (apply (apply f_int.<= x) y))))
(declare f_int.div term)
(define int.div (# x term (# y term (apply (apply f_int.div x) y))))
(declare f_int.mod term)
(define int.mod (# x term (# y term (apply (apply f_int.mod x) y))))
(declare f_int.div_total term)
(define int.div_total (# x term (# y term (apply (apply f_int.div_total x) y))))
(declare f_int.mod_total term)
(define int.mod_total (# x term (# y term (apply (apply f_int.mod_total x) y))))

; Arrays
(declare f_select term)
(define select (# x term (# y term (apply (apply f_select x) y))))
(declare f_store term)
(define store (# x term (# y term (# z term (apply (apply (apply f_store x) y) z)))))
(declare f_array_const (! v type term))
(define array_const (# x term (apply f_array_const x)))

; Strings
(declare emptystr term)
(declare char (! v mpz term))
(declare f_str.len term)
(define str.len (# x term (apply f_str.len x)))
(declare f_str.++ term)
(define str.++ (# x term (# y term (apply (apply f_str.++ x) y))))
(declare f_str.substr term)
(define str.substr (# x term (# y term (# z term (apply (apply (apply f_str.substr x) y) z)))))
(declare f_str.contains term)
(define str.contains (# x term (# y term (apply (apply f_str.contains x) y))))
(declare f_str.replace term)
(define str.replace (# x term (# y term (# z term (apply (apply (apply f_str.replace x) y) z)))))
(declare f_str.indexof term)
(define str.indexof (# x term (# y term (# z term (apply (apply (apply f_str.indexof x) y) z)))))
(declare f_str.prefixof term)
(define str.prefixof (# x term (# y term (apply (apply f_str.prefixof x) y))))
(declare f_str.suffixof term)
(define str.suffixof (# x term (# y term (apply (apply f_str.suffixof x) y))))
(declare f_str.rev term)
(define str.rev (# x term (apply f_str.rev x)))
(declare f_str.tolower term)
(define str.tolower (# x term (apply f_str.tolower x)))
(declare f_str.toupper term)
(define str.toupper (# x term (apply f_str.toupper x)))
(declare f_str.to_code term)
(define str.to_code (# x term (apply f_str.to_code x)))
(declare f_str.from_code term)
(define str.from_code (# x term (apply f_str.from_code x)))
(declare f_str.is_digit term)
(define str.is_digit (# x term (apply f_str.is_digit x)))
(declare f_str.to_int term)
(define str.to_int (# x term (apply f_str.to_int x)))
(declare f_str.from_int term)
(define str.from_int (# x term (apply f_str.from_int x)))
(declare f_str.< term)
(define str.< (# x term (# y term (apply (apply f_str.< x) y))))
(declare f_str.<= term)
(define str.<= (# x term (# y term (apply (apply f_str.<= x) y))))
; Regular expressions
(declare re.allchar term)
(declare re.none term)
(declare re.all term)
(declare f_str.to_re term)
(define str.to_re (# x term (apply f_str.to_re x)))
(declare f_re.* term)
(define re.* (# x term (apply f_re.* x)))
(declare f_re.+ term)
(define re.+ (# x term (apply f_re.+ x)))
(declare f_re.opt term)
(define re.opt (# x term (apply f_re.opt x)))
(declare f_re.comp term)
(define re.comp (# x term (apply f_re.comp x)))
(declare f_re.range term)
(define re.range (# x term (# y term (apply (apply f_re.range x) y))))
(declare f_re.++ term)
(define re.++ (# x term (# y term (apply (apply f_re.++ x) y))))
(declare f_re.inter term)
(define re.inter (# x term (# y term (apply (apply f_re.inter x) y))))
(declare f_re.union term)
(define re.union (# x term (# y term (apply (apply f_re.union x) y))))
(declare f_re.diff term)
(define re.diff (# x term (# y term (apply (apply f_re.diff x) y))))
(declare f_re.loop (! n1 mpz (! n2 mpz term)))
(define re.loop (# n1 mpz (# n2 mpz (# x term (apply (f_re.loop n1 n2) x)))))
(declare f_str.in_re term)
(define str.in_re (# x term (# y term (apply (apply f_str.in_re x) y))))
; Sequences
(declare f_seq.unit term)
(define seq.unit (# x term (apply f_seq.unit x)))
(declare f_seq.nth term)
(define seq.nth (# x term (apply f_seq.nth x)))
(declare f_seq.len term)
(define seq.len (# x term (apply f_seq.len x)))
(declare f_seq.++ term)
(define seq.++ (# x term (# y term (apply (apply f_seq.++ x) y))))
(declare f_seq.extract term)
(define seq.extract (# x term (# y term (# z term (apply (apply (apply f_seq.extract x) y) z)))))
(declare f_seq.contains term)
(define seq.contains (# x term (# y term (apply (apply f_seq.contains x) y))))
(declare f_seq.replace term)
(define seq.replace (# x term (# y term (# z term (apply (apply (apply f_seq.replace x) y) z)))))
(declare f_seq.indexof term)
(define seq.indexof (# x term (# y term (# z term (apply (apply (apply f_seq.indexof x) y) z)))))
(declare f_seq.prefixof term)
(define seq.prefixof (# x term (# y term (apply (apply f_seq.prefixof x) y))))
(declare f_seq.suffixof term)
(define seq.suffixof (# x term (# y term (apply (apply f_seq.suffixof x) y))))
(declare f_seq.rev term)
(define seq.rev (# x term (apply f_seq.rev x)))

; Bit-vectors
(declare bv (! b bitvec term))
(declare f_bvnot term)
(define bvnot (# x term (apply f_bvnot x)))
(declare f_bvand term)
(define bvand (# x term (# y term (apply (apply f_bvand x) y))))
(declare f_bvor term)
(define bvor (# x term (# y term (apply (apply f_bvor x) y))))
(declare f_bvxor term)
(define bvxor (# x term (# y term (apply (apply f_bvxor x) y))))
(declare f_bvnand term)
(define bvnand (# x term (# y term (apply (apply f_bvnand x) y))))
(declare f_bvnor term)
(define bvnor (# x term (# y term (apply (apply f_bvnor x) y))))
(declare f_bvxnor term)
(define bvxnor (# x term (# y term (apply (apply f_bvxnor x) y))))
(declare f_bvmul term)
(define bvmul (# x term (# y term (apply (apply f_bvmul x) y))))
(declare f_bvneg term)
(define bvneg (# x term (apply f_bvneg x)))
(declare f_bvadd term)
(define bvadd (# x term (# y term (apply (apply f_bvadd x) y))))
(declare f_bvsub term)
(define bvsub (# x term (# y term (apply (apply f_bvsub x) y))))
(declare f_bvudiv term)
(define bvudiv (# x term (# y term (apply (apply f_bvudiv x) y))))
(declare f_bvurem term)
(define bvurem (# x term (# y term (apply (apply f_bvurem x) y))))
(declare f_bvsdiv term)
(define bvsdiv (# x term (# y term (apply (apply f_bvsdiv x) y))))
(declare f_bvsrem term)
(define bvsrem (# x term (# y term (apply (apply f_bvsrem x) y))))
(declare f_bvsmod term)
(define bvsmod (# x term (# y term (apply (apply f_bvsmod x) y))))
(declare f_bvshl term)
(define bvshl (# x term (# y term (apply (apply f_bvshl x) y))))
(declare f_bvlshr term)
(define bvlshr (# x term (# y term (apply (apply f_bvlshr x) y))))
(declare f_bvashr term)
(define bvashr (# x term (# y term (apply (apply f_bvashr x) y))))
(declare f_bvult term)
(define bvult (# x term (# y term (apply (apply f_bvult x) y))))
(declare f_bvule term)
(define bvule (# x term (# y term (apply (apply f_bvule x) y))))
(declare f_bvugt term)
(define bvugt (# x term (# y term (apply (apply f_bvugt x) y))))
(declare f_bvuge term)
(define bvuge (# x term (# y term (apply (apply f_bvuge x) y))))
(declare f_bvslt term)
(define bvslt (# x term (# y term (apply (apply f_bvslt x) y))))
(declare f_bvsle term)
(define bvsle (# x term (# y term (apply (apply f_bvsle x) y))))
(declare f_bvsgt term)
(define bvsgt (# x term (# y term (apply (apply f_bvsgt x) y))))
(declare f_bvsge term)
(define bvsge (# x term (# y term (apply (apply f_bvsge x) y))))
(declare f_bvcomp term)
(define bvcomp (# x term (# y term (apply (apply f_bvcomp x) y))))
(declare f_concat term)
(define concat (# x term (# y term (apply (apply f_concat x) y))))
(declare f_rotate_left (! v mpz term))
(define rotate_left (# x mpz (# y term (apply (f_rotate_left x) y))))
(declare f_rotate_right (! v mpz term))
(define rotate_right (# x mpz (# y term (apply (f_rotate_right x) y))))
(declare f_zero_extend (! v mpz term))
(define zero_extend (# x mpz (# y term (apply (f_zero_extend x) y))))
(declare f_sign_extend (! v mpz term))
(define sign_extend (# x mpz (# y term (apply (f_sign_extend x) y))))
(declare f_repeat (! v mpz term))
(define repeat (# x mpz (# y term (apply (f_repeat x) y))))
(declare f_extract (! i mpz (! j mpz term)))
(define extract (# x mpz (# y mpz (# z term (apply (f_extract x y) z)))))

; Sets
(declare emptyset (! s sort term))
(declare f_singleton term)
(define singleton (# x term (apply f_singleton x)))
(declare f_union term)
(define union (# x term (# y term (apply (apply f_union x) y))))
(declare f_intersection term)
(define intersection (# x term (# y term (apply (apply f_intersection x) y))))
(declare f_setminus term)
(define setminus (# x term (# y term (apply (apply f_setminus x) y))))
(declare f_member term)
(define member (# x term (# y term (apply (apply f_member x) y))))
(declare f_subset term)
(define subset (# x term (# y term (apply (apply f_subset x) y))))
(declare f_card term)
(define card (# x term (apply f_card x)))
