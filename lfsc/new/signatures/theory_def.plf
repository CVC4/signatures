; sorts :
(declare Bool sort)
(declare Int sort)
(declare Real sort)
(declare String sort)
(declare RegLan sort)

;Arith:
(declare int (! v mpz term))
(declare f_int.+ term)
(define int.+ (# x term (# y term (apply (apply f_int.+ x) y))))
(declare f_int.- term)
(define int.- (# x term (# y term (apply (apply f_int.- x) y))))
(declare f_int.* term)
(define int.* (# x term (# y term (apply (apply f_int.* x) y))))
(declare f_int.> term)
(define int.> (# x term (# y term (apply (apply f_int.> x) y))))
(declare f_int.>= term)
(define int.>= (# x term (# y term (apply (apply f_int.>= x) y))))
(declare f_int.< term)
(define int.< (# x term (# y term (apply (apply f_int.< x) y))))
(declare f_int.<= term)
(define int.<= (# x term (# y term (apply (apply f_int.<= x) y))))

; Strings
(declare emptystr term)
(declare char (! v mpz term))
(declare f_str.len term)
(define str.len (# x term (apply f_str.len x)))
(declare f_str.++ term)
(define str.++ (# x term (# y term (apply (apply f_str.++ x) y))))
(declare f_str.substr term)
(define str.substr (# x term (# y term (# z term (apply (apply (apply f_str.substr x) y) z)))))
(declare f_str.contains term)
(define str.contains (# x term (# y term (apply (apply f_str.contains x) y))))
(declare f_str.replace term)
(define str.replace (# x term (# y term (# z term (apply (apply (apply f_str.replace x) y) z)))))
(declare f_str.indexof term)
(define str.indexof (# x term (# y term (# z term (apply (apply (apply f_str.indexof x) y) z)))))
(declare f_str.prefixof term)
(define str.prefixof (# x term (# y term (apply (apply f_str.prefixof x) y))))
(declare f_str.suffixof term)
(define str.suffixof (# x term (# y term (apply (apply f_str.suffixof x) y))))
; Regular expressions
(declare re.allchar term)
(declare re.none term)
(declare re.all term)
(declare f_str.to_re term)
(define str.to_re (# x term (apply f_str.to_re x)))
(declare f_re.* term)
(define re.* (# x term (apply f_re.* x)))
(declare f_re.comp term)
(define re.comp (# x term (apply f_re.comp x)))
(declare f_re.range term)
(define re.range (# x term (# y term (apply (apply f_re.range x) y))))
(declare f_re.++ term)
(define re.++ (# x term (# y term (apply (apply f_re.++ x) y))))
(declare f_re.inter term)
(define re.inter (# x term (# y term (apply (apply f_re.inter x) y))))
(declare f_re.union term)
(define re.union (# x term (# y term (apply (apply f_re.union x) y))))
(declare f_re.loop (! n1 mpz (! n2 mpz term)))
(define re.loop (# n1 mpz (# n2 mpz (# x term (apply (f_re.loop n1 n2) x)))))
; membership
(declare f_str.in_re term)
(define str.in_re (# x term (# y term (apply (apply f_str.in_re x) y))))




